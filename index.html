<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>RE-Q | Smart Interval Learning</title>
<style>
    :root { --primary: #3498db; --bg: #f4f7f6; --text: #2c3e50; }
    body { font-family: 'Helvetica Neue', Arial, sans-serif; padding: 20px; max-width: 600px; margin: auto; background-color: var(--bg); color: var(--text); }
    h2 { text-align: center; letter-spacing: 4px; color: var(--primary); margin-bottom: 20px; font-weight: 900; }
    #setupArea { background: white; padding: 20px; border-radius: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); }
    #dropZone { border: 2px dashed #ccc; padding: 30px; text-align: center; border-radius: 10px; background: #fafafa; transition: 0.3s; cursor: pointer; color: #7f8c8d; }
    #dropZone.dragover { border-color: var(--primary); background: #eef7fe; color: var(--primary); }
    #pasteArea { width: 100%; height: 100px; margin-top: 15px; border-radius: 8px; border: 1px solid #ddd; padding: 12px; box-sizing: border-box; font-size: 14px; resize: none; outline: none; }
    .start-btn { width: 100%; padding: 12px; background: var(--primary); color: white; border: none; border-radius: 8px; margin-top: 15px; cursor: pointer; font-weight: bold; font-size: 16px; transition: 0.2s; }
    
    #quizArea { background: white; padding: 30px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.08); }
    #question { font-size: 28px; font-weight: bold; margin-bottom: 20px; min-height: 45px; }
    
    /* ズレ防止：box-sizingをborder-boxにし、高さを厳密に固定 */
    #answer { 
        font-size: 22px; 
        padding: 15px; 
        width: 100%; 
        border: 2px solid #eee; 
        border-radius: 10px; 
        outline: none; 
        box-sizing: border-box; 
        height: 60px; 
        display: block;
    }
    #answer:focus { border-color: var(--primary); }
    #answer.showing-answer { color: #e74c3c; background-color: #fdf2f2; border-color: #fab1a0; font-weight: bold; cursor: default; }
    
    #score { margin-top: 25px; font-size: 14px; color: #95a5a6; display: flex; justify-content: space-between; border-top: 1px solid #f0f0f0; padding-top: 20px; }
    #score b { color: var(--text); }
    .hidden { display: none; }
    #report { margin-top: 20px; padding: 15px; border-radius: 10px; background: #e8f4fd; color: #2980b9; font-weight: bold; text-align: center; }
</style>
</head>
<body>

<h2>RE-Q</h2>

<div id="setupArea">
    <div id="dropZone">
        CSVファイルをドロップ、またはクリックして選択
        <input type="file" id="fileInput" accept=".csv,.txt" class="hidden">
    </div>
    <textarea id="pasteArea" placeholder="ここに「答え,問題」の形式で貼り付け"></textarea>
    <div style="margin: 15px 0; text-align: center;">
        <label style="cursor: pointer; font-size: 14px; color: var(--text); display: flex; align-items: center; justify-content: center; gap: 8px;">
            <input type="checkbox" id="shuffleMode" style="width: 18px; height: 18px; cursor: pointer;"> 
            問題をランダムに出題する
        </label>
    </div>
    <button class="start-btn" onclick="startWithPaste()">START LEARNING</button>
</div>

<div id="quizArea" class="hidden">
    <div id="question"></div>
    <input type="text" id="answer" autocomplete="off" placeholder="Answer...">
    <div id="score">
        <span>残り: <b id="remainingCount">0</b></span>
        <span>正解: <b id="correctCount">0</b> / 不正解: <b id="mistakeCount">0</b></span>
    </div>
    <div id="report" class="hidden"></div>
</div>

<script>
let questions = [];
let mainQueue = [];
let consecutiveCorrect = 0, totalMistakes = 0;
let answeredOnceWrong = new Set();
let currentIndex = null, currentIsRevenge = false, isCorrectionMode = false;

const el = {
    setup: document.getElementById("setupArea"),
    quiz: document.getElementById("quizArea"),
    q: document.getElementById("question"),
    a: document.getElementById("answer"),
    correct: document.getElementById("correctCount"),
    mistake: document.getElementById("mistakeCount"),
    remain: document.getElementById("remainingCount"),
    drop: document.getElementById("dropZone"),
    file: document.getElementById("fileInput"),
    paste: document.getElementById("pasteArea"),
    report: document.getElementById("report"),
    shuffle: document.getElementById("shuffleMode")
};

el.drop.onclick = () => el.file.click();
el.drop.ondragover = (e) => { e.preventDefault(); el.drop.classList.add("dragover"); };
el.drop.ondragleave = () => el.drop.classList.remove("dragover");
el.drop.ondrop = (e) => { e.preventDefault(); el.drop.classList.remove("dragover"); handleFile(e.dataTransfer.files[0]); };
el.file.onchange = (e) => handleFile(e.target.files[0]);

function handleFile(file) {
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (e) => initQuiz(e.target.result);
    reader.readAsText(file);
}

function startWithPaste() {
    if(el.paste.value.trim()) initQuiz(el.paste.value);
}

function initQuiz(text) {
    questions = text.split(/\r?\n/).filter(l => l.includes(",")).map(l => { 
        const p = l.split(","); return { a: p[0].trim(), q: p[1].trim() }; 
    });
    if(questions.length === 0) return alert("データがありません。");
    el.setup.classList.add("hidden");
    el.quiz.classList.remove("hidden");
    mainQueue = questions.map((_, i) => ({ index: i, isRevenge: false }));

    if (el.shuffle && el.shuffle.checked) {
        for (let i = mainQueue.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [mainQueue[i], mainQueue[j]] = [mainQueue[j], mainQueue[i]];
        }
    }
    showNext();
}

/**
 * キー入力制御
 */
el.a.onkeydown = (e) => {
    if (el.a.classList.contains("showing-answer")) {
        if (e.key === "Enter" || e.key === "Backspace") {
            e.preventDefault();
            el.a.value = "";
            el.a.readOnly = false;
            el.a.classList.remove("showing-answer");
            return;
        } else {
            e.preventDefault();
            return;
        }
    }
    if (e.key === "Enter") checkAnswer();
};

el.a.oninput = (e) => {
    if (el.a.classList.contains("showing-answer")) {
        el.a.value = questions[currentIndex].a;
    }
};

function normalize(str, allowIgnoreBrackets = false) {
    if (!str) return "";
    let res = str.replace(/[！-～]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
    if (allowIgnoreBrackets) {
        res = res.replace(/\(.*?\)|（.*?）/g, '');
    }
    return res.replace(/[^a-zA-Z0-9ぁ-んァ-ヶ亜-熙]/g, '').toLowerCase();
}

function checkAnswer() {
    const user = el.a.value.trim();
    const correctRaw = questions[currentIndex].a;
    const isCorrect = (user !== "" && normalize(user) === normalize(correctRaw)) || 
                      (user !== "" && normalize(user) === normalize(correctRaw, true));

    if (isCorrect) {
        if (isCorrectionMode) {
            // 打ち直し成功時
            const retryIdx = currentIndex; 
            showNext();              // 先に次の問題(B)を表示。配列の先頭は(C)になる
            injectRevenge(retryIdx); // 残った配列の2番目以降に(A)を予約
        } else {
            // 初回正解、または再出題(Revenge)の正解時
            if (currentIsRevenge) { 
                totalMistakes = Math.max(0, totalMistakes - 1); 
                consecutiveCorrect++; 
            } else if (!answeredOnceWrong.has(currentIndex)) { 
                consecutiveCorrect++; 
            }
            showNext();
        }
    } else {
        // 不正解時の処理（変更なし）
        if (!answeredOnceWrong.has(currentIndex)) { 
            totalMistakes++; 
            answeredOnceWrong.add(currentIndex); 
        }
        updateScore();
        isCorrectionMode = true;
        el.a.readOnly = true; 
        el.a.value = correctRaw; 
        el.a.classList.add("showing-answer");
    }
}

function injectRevenge(idx) {
    if(mainQueue.some(item => item.index === idx && item.isRevenge)) return;

    // 1. 最後に予約されたRの位置を探す（なければ現在の画面の次=1とする）
    const lastRIndex = mainQueue.findLastIndex(item => item.isRevenge);
    
    // 2. 確率の抽選
    const isChain = Math.random() < 0.33; // 33%で隣接
    const N = (Math.random() < 0.75 ? 2 : 3); // 75%で2つあき、25%で3つあき

    // 3. 挿入位置を決定
    let bestPos;
    if (isChain && lastRIndex !== -1) {
        bestPos = lastRIndex + 1; // 隣接
    } else {
        // 前のRから「N+1」離れた位置、または今の次の次の次(2)以降の遠い方を採用
        const basePos = (lastRIndex !== -1) ? lastRIndex + N + 1 : N;
        bestPos = Math.max(2, basePos);
    }

    // 4. 挿入（配列の長さを超えてもspliceは末尾に追加してくれるので安心）
    mainQueue.splice(bestPos, 0, { index: idx, isRevenge: true });
}

function showNext() {
    if (mainQueue.length === 0) return finishQuiz();
    const next = mainQueue.shift();
    currentIndex = next.index;
    currentIsRevenge = next.isRevenge;
    isCorrectionMode = false;

    el.q.textContent = questions[currentIndex].q;
    el.a.readOnly = false;
    el.a.value = ""; 
    el.a.classList.remove("showing-answer");
    
    // フォーカスとズレ対策
    setTimeout(() => {
        el.a.focus();
    }, 10);
    updateScore();
}

function updateScore() {
    el.correct.textContent = consecutiveCorrect;
    el.mistake.textContent = totalMistakes;
    el.remain.textContent = mainQueue.length;
}

function finishQuiz() {
    el.q.textContent = "All Clear!";
    el.a.classList.add("hidden");
    el.report.innerHTML = `正解数: ${consecutiveCorrect} <br> 未習得数: ${totalMistakes}`;
    el.report.classList.remove("hidden");
}
</script>
</body>
</html>